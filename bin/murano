#!/usr/bin/env ruby

require 'rubygems'
require 'commander/import'
require 'pathname'
require 'MrMurano'
require 'pp'
require 'dotenv'
require 'highline'
require 'rainbow'
Dotenv.load

Signal.trap('INT', 'EXIT') # Don't drop traces on ^C

program :version, MrMurano::VERSION
program :description, %{Manage a Solution and Product in Exosite's Murano}

global_option('-V', '--verbose', 'Be chatty') {
  $cfg['tool.verbose'] = true
}
global_option('-n', '--dry', %{Don't run actions that make changes}) {
  $cfg['tool.dry'] = true
  $cfg['tool.verbose'] = true # dry implies verbose
}
global_option('-L', '--curl', 'Print out a curl command for each network call') {
  $cfg['tool.curldebug'] = true
}
global_option '--skip-plugins', %{Don't load plugins. Good for when one goes bad.}

global_option('-C', '--configfile FILE', %{Load additional configuration file}) {|file|
  # this is called after all of the top level code in this file.
  $cfg.load_specific(file)
}
global_option('-c', '--config KEY=VALUE', %{Set a single config key}) {|param|
  key, value = param.split('=', 2)
  # a=b :> ["a","b"]
  # a= :> ["a",""]
  # a :> ["a"]
  raise "Bad config '#{param}'" if key.nil?
  if value.nil? then
    $cfg[key] = 'true'
  else
    $cfg[key] = value
  end
}
global_option('--no-color', %{Disable fancy output}) {
  $cfg['tool.no-progress'] = true
  HighLine.use_color = false
  Rainbow.enabled = false
}
global_option('--no-progress', %{Disable spinner and progress message}) {
  $cfg['tool.no-progress'] = true
}

default_command :help
#default_command :syncup

$cfg = MrMurano::Config.new
$cfg.load
$project = MrMurano::ProjectFile.new
$project.load

# Basic command support is:
# - read/write config file in [Project, User, System] (all are optional)
# - TODO: Introspection for tab completion.
# - TODO: Look for tools in PATH that are +x and "murano-foo..."


# Look for plug-ins
pgds = [
  Pathname.new(Dir.home) + '.mrmurano' + 'plugins',
  Pathname.new(Dir.home) + '.murano' + 'plugins'
]
# Add plugin dirs from configs
# This is run before the command line options are parsed, so need to check old way.
if not ARGV.include? '--skip-plugins' then
  pgds << Pathname.new(ENV['MR_MURANO_PLUGIN_DIR']) if ENV.has_key? 'MR_MURANO_PLUGIN_DIR'
  pgds << Pathname.new(ENV['MURANO_PLUGIN_DIR']) if ENV.has_key? 'MURANO_PLUGIN_DIR'
  pgds.each do |path|
    next unless path.exist?
    path.each_child do |plugin|
      next if plugin.directory?
      next unless plugin.readable?
      next if plugin.basename.fnmatch('.*') # don't read anything starting with .
      begin
        require plugin.to_s
      rescue Exception => e
        $stderr.puts "Failed to load plugin at #{plugin} because #{e}"
      end
    end
  end
end

#  vim: set ai et sw=2 ts=2 :
